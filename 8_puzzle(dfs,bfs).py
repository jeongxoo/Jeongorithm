# -*- coding: utf-8 -*-
"""8_puzzle(DFS,BFS)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Uxrm50GLOz4gdY-gTf-bvuoFzEfl__mV
"""

#8-puzzle bfs(너비 우선 탐색), dfs(깊이 우선 탐색)
import collections
import copy
import time

goal = [1,2,3,
        4,5,6,
        7,8,0]

puzzle = [1,2,3,
          4,5,6,
          0,7,8]

op = ['UP', 'DOWN', 'RIGHT', 'LEFT']

#---------- display ----------#
def display(puzzle):
    print(" -----------")
    print("| %d | %d | %d |" %(puzzle[0], puzzle[1], puzzle[2]))
    print(" -----------")
    print("| %d | %d | %d |" %(puzzle[3], puzzle[4], puzzle[5]))
    print(" -----------")
    print("| %d | %d | %d |" %(puzzle[6], puzzle[7], puzzle[8]))
    print(" -----------")

print("Goal")
display(goal)

print("Root")
display(puzzle)

#노드 클래스
class Node:
    def __init__(self, state):
        self.state = state

#---------- DFS ----------#
#깊이 우선 탐색
def depth_first_search(puzzle):
    visit = []                          #방문
    stack = collections.deque([puzzle]) #방문X

    print("Goal : ", goal) #

    while stack is not Node: #
        print("\n====================")
        print("stack : ", stack)
        
        xNode = stack.pop()             #stack.pop > 후입선출

        print("현상태 출력 xNode : ", xNode, "\n")
        display(xNode)                  #현재 상태 출력

        if xNode == goal:               
            return print("\nSUCESS!")

        else:                           
            visit.append(xNode)         
            print("visit : ", visit)    

            
            index = checkPosition(xNode) 
            print("'0'index :", index)

            
            for oper in op: 
                newNode = createNode(stack, visit, copy.deepcopy(xNode), index, oper)
                print("\nnewNode : ", oper, newNode) 

                if newNode is not None:     
                    print()

#---------- BFS ----------#
#너비 우선 탐색
def breadth_first_search(puzzle):

    visit = []                          # 방문         
    queue = collections.deque([puzzle]) # 방문X

    print("Goal : ", goal)

    while queue is not Node:
        print("\n====================")
        print("초기 queue : ", queue)
        
        xNode = queue.popleft()         # queue.popleft > 선입선출

        print("xNode : ", xNode, "\n")
        display(xNode)              #현재 상태 출력

        if xNode == goal:
            return print("\nSUCESS!")

        else:
            visit.append(xNode)
            print("visit : ", visit)

            index = checkPosition(xNode)
            print("'0'index :", index)

            for oper in op:
                newNode = createNode(queue, visit, copy.deepcopy(xNode), index, oper)
                print("\nnewNode : ", oper, newNode)

                if newNode is not None:
                    queue.append(newNode)
                    print(" : ", queue)
                    print()

#---------- checkPosition ----------#
#0의 위치를 체크하는 함수
def checkPosition(xNode):
    i = xNode.index(0)  #0의 인덱스를 반
    return i

#---------- createNode ----------#
#newNode생성 함수
def createNode(stack, visit, newNode, i, oper):  
    if oper == 'UP':
        if (i >= 3): 
            newNode[i] = newNode[i - 3]
            newNode[i - 3] = 0

            if newNode in visit or newNode in stack: 
                return None 
            else:
                return newNode
            
            
    if oper == 'DOWN':
        if (i < 6): # 0의 위치가 6미만일 경우 내릴 수 있기 때문에 
            newNode[i] = newNode[i + 3] # 3을 더해줌
            newNode[i + 3] = 0

            if newNode in visit or newNode in stack:
                return None
            else:
                return newNode

    if oper == 'RIGHT': 
        if ((i%3) < 2): 
            newNode[i] = newNode[i + 1] # 1더해줌
            newNode[i + 1] = 0

            if newNode in visit or newNode in stack:
                return None
            else:
                return newNode
            

    if oper == 'LEFT':
        if ((i%3) > 0): 
            newNode[i] = newNode[i - 1] 
            newNode[i - 1] = 0

            if newNode in visit or newNode in stack:
                return None
            else:
                return newNode

#---------- main ----------#
node = Node(puzzle)

print("\n*깊이 우선 탐색*\n")
start1 = time.time()        #시간측정 시작
depth_first_search(puzzle)
print("DFS 소요 시간 : ", time.time() - start1) #종료

start2 = time.time()        
print("\n*너비 우선 탐색*\n")
breadth_first_search(puzzle)
print("BFS소요 시간 : ", time.time() - start2)

